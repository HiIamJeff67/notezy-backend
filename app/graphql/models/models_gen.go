// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodels

import (
	"bytes"
	"fmt"
	"io"
	"notezy-backend/app/models/schemas/enums"
	"strconv"
	"time"

	"github.com/google/uuid"
)

type SearchConnection interface {
	IsSearchConnection()
	GetSearchPageInfo() *SearchPageInfo
	GetTotalCount() int32
	GetSearchTime() float64
}

type SearchEdge interface {
	IsSearchEdge()
	GetEncodedSearchCursor() string
}

type PublicBadge struct {
	EncodedSearchCursor string          `json:"encodedSearchCursor"`
	Title               string          `json:"title"`
	Description         string          `json:"description"`
	Type                enums.BadgeType `json:"type"`
	ImageURL            *string         `json:"imageURL,omitempty"`
	CreatedAt           time.Time       `json:"createdAt"`
	Users               []*PublicUser   `json:"users"`
}

type PublicTheme struct {
	EncodedSearchCursor string      `json:"encodedSearchCursor"`
	Name                string      `json:"name"`
	Version             string      `json:"version"`
	IsDefault           bool        `json:"isDefault"`
	DownloadURL         *string     `json:"downloadURL,omitempty"`
	DownloadCount       int32       `json:"downloadCount"`
	CreatedAt           time.Time   `json:"createdAt"`
	UpdatedAt           time.Time   `json:"updatedAt"`
	Author              *PublicUser `json:"author"`
}

type PublicUser struct {
	EncodedSearchCursor string           `json:"encodedSearchCursor"`
	Name                string           `json:"name"`
	DisplayName         string           `json:"displayName"`
	Email               string           `json:"email"`
	Role                enums.UserRole   `json:"role"`
	Plan                enums.UserPlan   `json:"plan"`
	Status              enums.UserStatus `json:"status"`
	CreatedAt           time.Time        `json:"createdAt"`
	UpdatedAt           time.Time        `json:"updatedAt"`
	UserInfo            *PublicUserInfo  `json:"userInfo"`
	Badges              []*PublicBadge   `json:"badges"`
	Themes              []*PublicTheme   `json:"themes"`
}

type PublicUserInfo struct {
	CoverBackgroundURL *string          `json:"coverBackgroundURL,omitempty"`
	AvatarURL          *string          `json:"avatarURL,omitempty"`
	Header             *string          `json:"header,omitempty"`
	Introduction       *string          `json:"introduction,omitempty"`
	Gender             enums.UserGender `json:"gender"`
	Country            *enums.Country   `json:"country,omitempty"`
	BirthDate          time.Time        `json:"birthDate"`
	UpdatedAt          time.Time        `json:"updatedAt"`
}

type PublicUsersToBadges struct {
	UserID    uuid.UUID    `json:"userId"`
	BadgeID   uuid.UUID    `json:"badgeId"`
	CreatedAt time.Time    `json:"createdAt"`
	User      *PublicUser  `json:"user"`
	Badge     *PublicBadge `json:"badge"`
}

type Query struct {
}

type SearchPageInfo struct {
	HasNextPage              bool    `json:"hasNextPage"`
	HasPreviousPage          bool    `json:"hasPreviousPage"`
	StartEncodedSearchCursor *string `json:"startEncodedSearchCursor,omitempty"`
	EndEncodedSearchCursor   *string `json:"endEncodedSearchCursor,omitempty"`
}

type SearchableBadgeConnection struct {
	SearchEdges    []*SearchableBadgeEdge `json:"searchEdges"`
	SearchPageInfo *SearchPageInfo        `json:"searchPageInfo"`
	TotalCount     int32                  `json:"totalCount"`
	SearchTime     float64                `json:"searchTime"`
}

func (SearchableBadgeConnection) IsSearchConnection()                     {}
func (this SearchableBadgeConnection) GetSearchPageInfo() *SearchPageInfo { return this.SearchPageInfo }
func (this SearchableBadgeConnection) GetTotalCount() int32               { return this.TotalCount }
func (this SearchableBadgeConnection) GetSearchTime() float64             { return this.SearchTime }

type SearchableBadgeCursorFields struct {
	EncodedSearchCursor string `json:"encodedSearchCursor"`
}

type SearchableBadgeEdge struct {
	Node                *PublicBadge `json:"node"`
	EncodedSearchCursor string       `json:"encodedSearchCursor"`
}

func (SearchableBadgeEdge) IsSearchEdge()                       {}
func (this SearchableBadgeEdge) GetEncodedSearchCursor() string { return this.EncodedSearchCursor }

type SearchableBadgeFilters struct {
	Type *enums.BadgeType `json:"type,omitempty"`
}

type SearchableBadgeInput struct {
	Query      string                  `json:"query"`
	After      *string                 `json:"after,omitempty"`
	First      *int32                  `json:"first,omitempty"`
	Filters    *SearchableBadgeFilters `json:"filters,omitempty"`
	SortBy     *SearchableBadgeSortBy  `json:"sortBy,omitempty"`
	SortOrderr *SearchableSortOrder    `json:"sortOrderr,omitempty"`
}

type SearchableThemeConnection struct {
	SearchEdges    []*SearchableThemeEdge `json:"searchEdges"`
	SearchPageInfo *SearchPageInfo        `json:"searchPageInfo"`
	TotalCount     int32                  `json:"totalCount"`
	SearchTime     float64                `json:"searchTime"`
}

func (SearchableThemeConnection) IsSearchConnection()                     {}
func (this SearchableThemeConnection) GetSearchPageInfo() *SearchPageInfo { return this.SearchPageInfo }
func (this SearchableThemeConnection) GetTotalCount() int32               { return this.TotalCount }
func (this SearchableThemeConnection) GetSearchTime() float64             { return this.SearchTime }

type SearchableThemeCursorFields struct {
	EncodedSearchCursor string `json:"encodedSearchCursor"`
}

type SearchableThemeEdge struct {
	Node                *PublicTheme `json:"node"`
	EncodedSearchCursor string       `json:"encodedSearchCursor"`
}

func (SearchableThemeEdge) IsSearchEdge()                       {}
func (this SearchableThemeEdge) GetEncodedSearchCursor() string { return this.EncodedSearchCursor }

type SearchableThemeFilters struct {
	IsDefault                *bool  `json:"isDefault,omitempty"`
	DownloadCountGreaterThan *int32 `json:"downloadCountGreaterThan,omitempty"`
}

type SearchableThemeInput struct {
	Query     string                  `json:"query"`
	After     *string                 `json:"after,omitempty"`
	First     *int32                  `json:"first,omitempty"`
	Filters   *SearchableThemeFilters `json:"filters,omitempty"`
	SortBy    *SearchableThemeSortBy  `json:"sortBy,omitempty"`
	SortOrder *SearchableSortOrder    `json:"sortOrder,omitempty"`
}

type SearchableUserConnection struct {
	SearchEdges    []*SearchableUserEdge `json:"searchEdges"`
	SearchPageInfo *SearchPageInfo       `json:"searchPageInfo"`
	TotalCount     int32                 `json:"totalCount"`
	SearchTime     float64               `json:"searchTime"`
}

func (SearchableUserConnection) IsSearchConnection()                     {}
func (this SearchableUserConnection) GetSearchPageInfo() *SearchPageInfo { return this.SearchPageInfo }
func (this SearchableUserConnection) GetTotalCount() int32               { return this.TotalCount }
func (this SearchableUserConnection) GetSearchTime() float64             { return this.SearchTime }

type SearchableUserCursorFields struct {
	EncodedSearchCursor string `json:"encodedSearchCursor"`
}

type SearchableUserEdge struct {
	Node                *PublicUser `json:"node"`
	EncodedSearchCursor string      `json:"encodedSearchCursor"`
}

func (SearchableUserEdge) IsSearchEdge()                       {}
func (this SearchableUserEdge) GetEncodedSearchCursor() string { return this.EncodedSearchCursor }

type SearchableUserFilters struct {
	Role      *enums.UserRole   `json:"role,omitempty"`
	Plan      *enums.UserPlan   `json:"plan,omitempty"`
	Status    *enums.UserStatus `json:"status,omitempty"`
	HasAvatar *bool             `json:"hasAvatar,omitempty"`
	Country   *enums.Country    `json:"country,omitempty"`
	IsOnline  *bool             `json:"isOnline,omitempty"`
}

type SearchableUserInput struct {
	Query     string                 `json:"query"`
	After     *string                `json:"after,omitempty"`
	First     *int32                 `json:"first,omitempty"`
	Filters   *SearchableUserFilters `json:"filters,omitempty"`
	SortBy    *SearchableUserSortBy  `json:"sortBy,omitempty"`
	SortOrder *SearchableSortOrder   `json:"sortOrder,omitempty"`
}

type CountryCode string

const (
	CountryCodeCountryCode886 CountryCode = "COUNTRY_CODE_886"
	CountryCodeCountryCode81  CountryCode = "COUNTRY_CODE_81"
	CountryCodeCountryCode60  CountryCode = "COUNTRY_CODE_60"
	CountryCodeCountryCode65  CountryCode = "COUNTRY_CODE_65"
	CountryCodeCountryCode86  CountryCode = "COUNTRY_CODE_86"
	CountryCodeCountryCode1   CountryCode = "COUNTRY_CODE_1"
	CountryCodeCountryCode44  CountryCode = "COUNTRY_CODE_44"
	CountryCodeCountryCode61  CountryCode = "COUNTRY_CODE_61"
)

var AllCountryCode = []CountryCode{
	CountryCodeCountryCode886,
	CountryCodeCountryCode81,
	CountryCodeCountryCode60,
	CountryCodeCountryCode65,
	CountryCodeCountryCode86,
	CountryCodeCountryCode1,
	CountryCodeCountryCode44,
	CountryCodeCountryCode61,
}

func (e CountryCode) IsValid() bool {
	switch e {
	case CountryCodeCountryCode886, CountryCodeCountryCode81, CountryCodeCountryCode60, CountryCodeCountryCode65, CountryCodeCountryCode86, CountryCodeCountryCode1, CountryCodeCountryCode44, CountryCodeCountryCode61:
		return true
	}
	return false
}

func (e CountryCode) String() string {
	return string(e)
}

func (e *CountryCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountryCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountryCode", str)
	}
	return nil
}

func (e CountryCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CountryCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CountryCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchableBadgeSortBy string

const (
	SearchableBadgeSortByRelevance SearchableBadgeSortBy = "RELEVANCE"
	SearchableBadgeSortByTitle     SearchableBadgeSortBy = "TITLE"
	SearchableBadgeSortByCreatedAt SearchableBadgeSortBy = "CREATED_AT"
)

var AllSearchableBadgeSortBy = []SearchableBadgeSortBy{
	SearchableBadgeSortByRelevance,
	SearchableBadgeSortByTitle,
	SearchableBadgeSortByCreatedAt,
}

func (e SearchableBadgeSortBy) IsValid() bool {
	switch e {
	case SearchableBadgeSortByRelevance, SearchableBadgeSortByTitle, SearchableBadgeSortByCreatedAt:
		return true
	}
	return false
}

func (e SearchableBadgeSortBy) String() string {
	return string(e)
}

func (e *SearchableBadgeSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableBadgeSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableBadgeSortBy", str)
	}
	return nil
}

func (e SearchableBadgeSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableBadgeSortBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableBadgeSortBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchableSortOrder string

const (
	SearchableSortOrderAsc  SearchableSortOrder = "ASC"
	SearchableSortOrderDesc SearchableSortOrder = "DESC"
)

var AllSearchableSortOrder = []SearchableSortOrder{
	SearchableSortOrderAsc,
	SearchableSortOrderDesc,
}

func (e SearchableSortOrder) IsValid() bool {
	switch e {
	case SearchableSortOrderAsc, SearchableSortOrderDesc:
		return true
	}
	return false
}

func (e SearchableSortOrder) String() string {
	return string(e)
}

func (e *SearchableSortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableSortOrder", str)
	}
	return nil
}

func (e SearchableSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableSortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableSortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchableThemeSortBy string

const (
	SearchableThemeSortByRelevance  SearchableThemeSortBy = "RELEVANCE"
	SearchableThemeSortByName       SearchableThemeSortBy = "NAME"
	SearchableThemeSortByLastUpdate SearchableThemeSortBy = "LAST_UPDATE"
	SearchableThemeSortByCreatedAt  SearchableThemeSortBy = "CREATED_AT"
)

var AllSearchableThemeSortBy = []SearchableThemeSortBy{
	SearchableThemeSortByRelevance,
	SearchableThemeSortByName,
	SearchableThemeSortByLastUpdate,
	SearchableThemeSortByCreatedAt,
}

func (e SearchableThemeSortBy) IsValid() bool {
	switch e {
	case SearchableThemeSortByRelevance, SearchableThemeSortByName, SearchableThemeSortByLastUpdate, SearchableThemeSortByCreatedAt:
		return true
	}
	return false
}

func (e SearchableThemeSortBy) String() string {
	return string(e)
}

func (e *SearchableThemeSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableThemeSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableThemeSortBy", str)
	}
	return nil
}

func (e SearchableThemeSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableThemeSortBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableThemeSortBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchableUserSortBy string

const (
	SearchableUserSortByRelevance  SearchableUserSortBy = "RELEVANCE"
	SearchableUserSortByName       SearchableUserSortBy = "NAME"
	SearchableUserSortByLastActive SearchableUserSortBy = "LAST_ACTIVE"
	SearchableUserSortByCreatedAt  SearchableUserSortBy = "CREATED_AT"
)

var AllSearchableUserSortBy = []SearchableUserSortBy{
	SearchableUserSortByRelevance,
	SearchableUserSortByName,
	SearchableUserSortByLastActive,
	SearchableUserSortByCreatedAt,
}

func (e SearchableUserSortBy) IsValid() bool {
	switch e {
	case SearchableUserSortByRelevance, SearchableUserSortByName, SearchableUserSortByLastActive, SearchableUserSortByCreatedAt:
		return true
	}
	return false
}

func (e SearchableUserSortBy) String() string {
	return string(e)
}

func (e *SearchableUserSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableUserSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableUserSortBy", str)
	}
	return nil
}

func (e SearchableUserSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableUserSortBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableUserSortBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
