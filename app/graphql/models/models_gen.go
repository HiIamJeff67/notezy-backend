// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodels

import (
	"bytes"
	"fmt"
	"io"
	"notezy-backend/app/models/schemas/enums"
	"strconv"
	"time"

	"github.com/google/uuid"
)

type SearchConnection interface {
	IsSearchConnection()
	GetSearchPageInfo() *SearchPageInfo
	GetTotalCount() int32
	GetSearchTime() float64
}

type SearchEdge interface {
	IsSearchEdge()
	GetSearchCursor() string
}

type PublicBadge struct {
	ID          uuid.UUID       `json:"id"`
	Title       string          `json:"title"`
	Description string          `json:"description"`
	Type        enums.BadgeType `json:"type"`
	ImageURL    *string         `json:"imageURL,omitempty"`
	CreatedAt   time.Time       `json:"createdAt"`
	Users       []*PublicUser   `json:"users"`
}

type PublicTheme struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Version     string      `json:"version"`
	IsDefault   bool        `json:"isDefault"`
	DownloadURL *string     `json:"downloadURL,omitempty"`
	CreatedAt   time.Time   `json:"createdAt"`
	UpdatedAt   time.Time   `json:"updatedAt"`
	Author      *PublicUser `json:"author"`
}

type PublicUser struct {
	Name        string           `json:"name"`
	DisplayName string           `json:"displayName"`
	Email       string           `json:"email"`
	Role        enums.UserRole   `json:"role"`
	Plan        enums.UserPlan   `json:"plan"`
	PrevStatus  enums.UserStatus `json:"prevStatus"`
	Status      enums.UserStatus `json:"status"`
	CreatedAt   time.Time        `json:"createdAt"`
	UpdatedAt   time.Time        `json:"updatedAt"`
	UserInfo    *PublicUserInfo  `json:"userInfo"`
	Badges      []*PublicBadge   `json:"badges"`
	Themes      []*PublicTheme   `json:"themes"`
}

type PublicUserInfo struct {
	CoverBackgroundURL *string          `json:"coverBackgroundURL,omitempty"`
	AvatarURL          *string          `json:"avatarURL,omitempty"`
	Header             *string          `json:"header,omitempty"`
	Introduction       *string          `json:"introduction,omitempty"`
	Gender             enums.UserGender `json:"gender"`
	Country            *enums.Country   `json:"country,omitempty"`
	BirthDate          time.Time        `json:"birthDate"`
	UpdatedAt          time.Time        `json:"updatedAt"`
}

type PublicUsersToBadges struct {
	UserID    uuid.UUID    `json:"userId"`
	BadgeID   uuid.UUID    `json:"badgeId"`
	CreatedAt time.Time    `json:"createdAt"`
	User      *PublicUser  `json:"user"`
	Badge     *PublicBadge `json:"badge"`
}

type Query struct {
}

type SearchPageInfo struct {
	HasNextPage       bool    `json:"hasNextPage"`
	HasPreviousPage   bool    `json:"hasPreviousPage"`
	StartSearchCursor *string `json:"startSearchCursor,omitempty"`
	EndSearchCursor   *string `json:"endSearchCursor,omitempty"`
}

type SearchableUserConnection struct {
	SearchEdges    []*SearchableUserEdge `json:"searchEdges"`
	SearchPageInfo *SearchPageInfo       `json:"searchPageInfo"`
	TotalCount     int32                 `json:"totalCount"`
	SearchTime     float64               `json:"searchTime"`
}

func (SearchableUserConnection) IsSearchConnection()                     {}
func (this SearchableUserConnection) GetSearchPageInfo() *SearchPageInfo { return this.SearchPageInfo }
func (this SearchableUserConnection) GetTotalCount() int32               { return this.TotalCount }
func (this SearchableUserConnection) GetSearchTime() float64             { return this.SearchTime }

type SearchableUserEdge struct {
	Node         *PublicUser `json:"node"`
	SearchCursor string      `json:"searchCursor"`
}

func (SearchableUserEdge) IsSearchEdge()                {}
func (this SearchableUserEdge) GetSearchCursor() string { return this.SearchCursor }

type SearchableUserFilters struct {
	Role      *enums.UserRole   `json:"role,omitempty"`
	Plan      *enums.UserPlan   `json:"plan,omitempty"`
	Status    *enums.UserStatus `json:"status,omitempty"`
	HasAvatar *bool             `json:"hasAvatar,omitempty"`
	Country   *enums.Country    `json:"country,omitempty"`
	IsOnline  *bool             `json:"isOnline,omitempty"`
}

type SearchableUserInput struct {
	Query     string                 `json:"query"`
	After     *string                `json:"after,omitempty"`
	First     *int32                 `json:"first,omitempty"`
	Filters   *SearchableUserFilters `json:"filters,omitempty"`
	SortBy    *SearchableUserSortBy  `json:"sortBy,omitempty"`
	SortOrder *SearchableSortOrder   `json:"sortOrder,omitempty"`
}

type CountryCode string

const (
	CountryCodeCountryCode886 CountryCode = "COUNTRY_CODE_886"
	CountryCodeCountryCode81  CountryCode = "COUNTRY_CODE_81"
	CountryCodeCountryCode60  CountryCode = "COUNTRY_CODE_60"
	CountryCodeCountryCode65  CountryCode = "COUNTRY_CODE_65"
	CountryCodeCountryCode86  CountryCode = "COUNTRY_CODE_86"
	CountryCodeCountryCode1   CountryCode = "COUNTRY_CODE_1"
	CountryCodeCountryCode44  CountryCode = "COUNTRY_CODE_44"
	CountryCodeCountryCode61  CountryCode = "COUNTRY_CODE_61"
)

var AllCountryCode = []CountryCode{
	CountryCodeCountryCode886,
	CountryCodeCountryCode81,
	CountryCodeCountryCode60,
	CountryCodeCountryCode65,
	CountryCodeCountryCode86,
	CountryCodeCountryCode1,
	CountryCodeCountryCode44,
	CountryCodeCountryCode61,
}

func (e CountryCode) IsValid() bool {
	switch e {
	case CountryCodeCountryCode886, CountryCodeCountryCode81, CountryCodeCountryCode60, CountryCodeCountryCode65, CountryCodeCountryCode86, CountryCodeCountryCode1, CountryCodeCountryCode44, CountryCodeCountryCode61:
		return true
	}
	return false
}

func (e CountryCode) String() string {
	return string(e)
}

func (e *CountryCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountryCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountryCode", str)
	}
	return nil
}

func (e CountryCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CountryCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CountryCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchableSortOrder string

const (
	SearchableSortOrderAsc  SearchableSortOrder = "ASC"
	SearchableSortOrderDesc SearchableSortOrder = "DESC"
)

var AllSearchableSortOrder = []SearchableSortOrder{
	SearchableSortOrderAsc,
	SearchableSortOrderDesc,
}

func (e SearchableSortOrder) IsValid() bool {
	switch e {
	case SearchableSortOrderAsc, SearchableSortOrderDesc:
		return true
	}
	return false
}

func (e SearchableSortOrder) String() string {
	return string(e)
}

func (e *SearchableSortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableSortOrder", str)
	}
	return nil
}

func (e SearchableSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableSortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableSortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SearchableUserSortBy string

const (
	SearchableUserSortByRelevance  SearchableUserSortBy = "RELEVANCE"
	SearchableUserSortByName       SearchableUserSortBy = "NAME"
	SearchableUserSortByLastActive SearchableUserSortBy = "LAST_ACTIVE"
	SearchableUserSortByCreatedAt  SearchableUserSortBy = "CREATED_AT"
)

var AllSearchableUserSortBy = []SearchableUserSortBy{
	SearchableUserSortByRelevance,
	SearchableUserSortByName,
	SearchableUserSortByLastActive,
	SearchableUserSortByCreatedAt,
}

func (e SearchableUserSortBy) IsValid() bool {
	switch e {
	case SearchableUserSortByRelevance, SearchableUserSortByName, SearchableUserSortByLastActive, SearchableUserSortByCreatedAt:
		return true
	}
	return false
}

func (e SearchableUserSortBy) String() string {
	return string(e)
}

func (e *SearchableUserSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchableUserSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchableUserSortBy", str)
	}
	return nil
}

func (e SearchableUserSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SearchableUserSortBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SearchableUserSortBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
