// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	gqlmodels "notezy-backend/app/graphql/models"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	PublicBadge struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageURL    func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	PublicTheme struct {
		Author      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DownloadURL func(childComplexity int) int
		ID          func(childComplexity int) int
		IsDefault   func(childComplexity int) int
		Name        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	PublicUser struct {
		Badges      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		Name        func(childComplexity int) int
		Plan        func(childComplexity int) int
		Role        func(childComplexity int) int
		Status      func(childComplexity int) int
		Themes      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UserInfo    func(childComplexity int) int
	}

	PublicUserInfo struct {
		AvatarURL          func(childComplexity int) int
		BirthDate          func(childComplexity int) int
		Country            func(childComplexity int) int
		CoverBackgroundURL func(childComplexity int) int
		Gender             func(childComplexity int) int
		Header             func(childComplexity int) int
		Introduction       func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
	}

	PublicUsersToBadges struct {
		Badge     func(childComplexity int) int
		BadgeID   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	Query struct {
		SearchUsers func(childComplexity int, input gqlmodels.SearchableUserInput) int
	}

	SearchPageInfo struct {
		EndSearchCursor   func(childComplexity int) int
		HasNextPage       func(childComplexity int) int
		HasPreviousPage   func(childComplexity int) int
		StartSearchCursor func(childComplexity int) int
	}

	SearchableUserConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchableUserEdge struct {
		Node         func(childComplexity int) int
		SearchCursor func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "PublicBadge.createdAt":
		if e.complexity.PublicBadge.CreatedAt == nil {
			break
		}

		return e.complexity.PublicBadge.CreatedAt(childComplexity), true

	case "PublicBadge.description":
		if e.complexity.PublicBadge.Description == nil {
			break
		}

		return e.complexity.PublicBadge.Description(childComplexity), true

	case "PublicBadge.id":
		if e.complexity.PublicBadge.ID == nil {
			break
		}

		return e.complexity.PublicBadge.ID(childComplexity), true

	case "PublicBadge.imageURL":
		if e.complexity.PublicBadge.ImageURL == nil {
			break
		}

		return e.complexity.PublicBadge.ImageURL(childComplexity), true

	case "PublicBadge.title":
		if e.complexity.PublicBadge.Title == nil {
			break
		}

		return e.complexity.PublicBadge.Title(childComplexity), true

	case "PublicBadge.type":
		if e.complexity.PublicBadge.Type == nil {
			break
		}

		return e.complexity.PublicBadge.Type(childComplexity), true

	case "PublicBadge.users":
		if e.complexity.PublicBadge.Users == nil {
			break
		}

		return e.complexity.PublicBadge.Users(childComplexity), true

	case "PublicTheme.author":
		if e.complexity.PublicTheme.Author == nil {
			break
		}

		return e.complexity.PublicTheme.Author(childComplexity), true

	case "PublicTheme.createdAt":
		if e.complexity.PublicTheme.CreatedAt == nil {
			break
		}

		return e.complexity.PublicTheme.CreatedAt(childComplexity), true

	case "PublicTheme.downloadURL":
		if e.complexity.PublicTheme.DownloadURL == nil {
			break
		}

		return e.complexity.PublicTheme.DownloadURL(childComplexity), true

	case "PublicTheme.id":
		if e.complexity.PublicTheme.ID == nil {
			break
		}

		return e.complexity.PublicTheme.ID(childComplexity), true

	case "PublicTheme.isDefault":
		if e.complexity.PublicTheme.IsDefault == nil {
			break
		}

		return e.complexity.PublicTheme.IsDefault(childComplexity), true

	case "PublicTheme.name":
		if e.complexity.PublicTheme.Name == nil {
			break
		}

		return e.complexity.PublicTheme.Name(childComplexity), true

	case "PublicTheme.updatedAt":
		if e.complexity.PublicTheme.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicTheme.UpdatedAt(childComplexity), true

	case "PublicTheme.version":
		if e.complexity.PublicTheme.Version == nil {
			break
		}

		return e.complexity.PublicTheme.Version(childComplexity), true

	case "PublicUser.badges":
		if e.complexity.PublicUser.Badges == nil {
			break
		}

		return e.complexity.PublicUser.Badges(childComplexity), true

	case "PublicUser.createdAt":
		if e.complexity.PublicUser.CreatedAt == nil {
			break
		}

		return e.complexity.PublicUser.CreatedAt(childComplexity), true

	case "PublicUser.displayName":
		if e.complexity.PublicUser.DisplayName == nil {
			break
		}

		return e.complexity.PublicUser.DisplayName(childComplexity), true

	case "PublicUser.email":
		if e.complexity.PublicUser.Email == nil {
			break
		}

		return e.complexity.PublicUser.Email(childComplexity), true

	case "PublicUser.name":
		if e.complexity.PublicUser.Name == nil {
			break
		}

		return e.complexity.PublicUser.Name(childComplexity), true

	case "PublicUser.plan":
		if e.complexity.PublicUser.Plan == nil {
			break
		}

		return e.complexity.PublicUser.Plan(childComplexity), true

	case "PublicUser.role":
		if e.complexity.PublicUser.Role == nil {
			break
		}

		return e.complexity.PublicUser.Role(childComplexity), true

	case "PublicUser.status":
		if e.complexity.PublicUser.Status == nil {
			break
		}

		return e.complexity.PublicUser.Status(childComplexity), true

	case "PublicUser.themes":
		if e.complexity.PublicUser.Themes == nil {
			break
		}

		return e.complexity.PublicUser.Themes(childComplexity), true

	case "PublicUser.updatedAt":
		if e.complexity.PublicUser.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicUser.UpdatedAt(childComplexity), true

	case "PublicUser.userInfo":
		if e.complexity.PublicUser.UserInfo == nil {
			break
		}

		return e.complexity.PublicUser.UserInfo(childComplexity), true

	case "PublicUserInfo.avatarURL":
		if e.complexity.PublicUserInfo.AvatarURL == nil {
			break
		}

		return e.complexity.PublicUserInfo.AvatarURL(childComplexity), true

	case "PublicUserInfo.birthDate":
		if e.complexity.PublicUserInfo.BirthDate == nil {
			break
		}

		return e.complexity.PublicUserInfo.BirthDate(childComplexity), true

	case "PublicUserInfo.country":
		if e.complexity.PublicUserInfo.Country == nil {
			break
		}

		return e.complexity.PublicUserInfo.Country(childComplexity), true

	case "PublicUserInfo.coverBackgroundURL":
		if e.complexity.PublicUserInfo.CoverBackgroundURL == nil {
			break
		}

		return e.complexity.PublicUserInfo.CoverBackgroundURL(childComplexity), true

	case "PublicUserInfo.gender":
		if e.complexity.PublicUserInfo.Gender == nil {
			break
		}

		return e.complexity.PublicUserInfo.Gender(childComplexity), true

	case "PublicUserInfo.header":
		if e.complexity.PublicUserInfo.Header == nil {
			break
		}

		return e.complexity.PublicUserInfo.Header(childComplexity), true

	case "PublicUserInfo.introduction":
		if e.complexity.PublicUserInfo.Introduction == nil {
			break
		}

		return e.complexity.PublicUserInfo.Introduction(childComplexity), true

	case "PublicUserInfo.updatedAt":
		if e.complexity.PublicUserInfo.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicUserInfo.UpdatedAt(childComplexity), true

	case "PublicUsersToBadges.badge":
		if e.complexity.PublicUsersToBadges.Badge == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.Badge(childComplexity), true

	case "PublicUsersToBadges.badgeId":
		if e.complexity.PublicUsersToBadges.BadgeID == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.BadgeID(childComplexity), true

	case "PublicUsersToBadges.createdAt":
		if e.complexity.PublicUsersToBadges.CreatedAt == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.CreatedAt(childComplexity), true

	case "PublicUsersToBadges.user":
		if e.complexity.PublicUsersToBadges.User == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.User(childComplexity), true

	case "PublicUsersToBadges.userId":
		if e.complexity.PublicUsersToBadges.UserID == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.UserID(childComplexity), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["input"].(gqlmodels.SearchableUserInput)), true

	case "SearchPageInfo.endSearchCursor":
		if e.complexity.SearchPageInfo.EndSearchCursor == nil {
			break
		}

		return e.complexity.SearchPageInfo.EndSearchCursor(childComplexity), true

	case "SearchPageInfo.hasNextPage":
		if e.complexity.SearchPageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.SearchPageInfo.HasNextPage(childComplexity), true

	case "SearchPageInfo.hasPreviousPage":
		if e.complexity.SearchPageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.SearchPageInfo.HasPreviousPage(childComplexity), true

	case "SearchPageInfo.startSearchCursor":
		if e.complexity.SearchPageInfo.StartSearchCursor == nil {
			break
		}

		return e.complexity.SearchPageInfo.StartSearchCursor(childComplexity), true

	case "SearchableUserConnection.searchEdges":
		if e.complexity.SearchableUserConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchableUserConnection.SearchEdges(childComplexity), true

	case "SearchableUserConnection.searchPageInfo":
		if e.complexity.SearchableUserConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchableUserConnection.SearchPageInfo(childComplexity), true

	case "SearchableUserConnection.searchTime":
		if e.complexity.SearchableUserConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchableUserConnection.SearchTime(childComplexity), true

	case "SearchableUserConnection.totalCount":
		if e.complexity.SearchableUserConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchableUserConnection.TotalCount(childComplexity), true

	case "SearchableUserEdge.node":
		if e.complexity.SearchableUserEdge.Node == nil {
			break
		}

		return e.complexity.SearchableUserEdge.Node(childComplexity), true

	case "SearchableUserEdge.searchCursor":
		if e.complexity.SearchableUserEdge.SearchCursor == nil {
			break
		}

		return e.complexity.SearchableUserEdge.SearchCursor(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputSearchableUserFilters,
		ec.unmarshalInputSearchableUserInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/enums/badge_type_enum.graphql", Input: `enum BadgeType {
  Diamond
  Golden
  Silver
  Bronze
  Steel
}
`, BuiltIn: false},
	{Name: "../schemas/enums/country_code_enum.graphql", Input: `enum CountryCode {
  COUNTRY_CODE_886 # Taiwan
  COUNTRY_CODE_81 # Japan
  COUNTRY_CODE_60 # Malaysia
  COUNTRY_CODE_65 # Singapore
  COUNTRY_CODE_86 # China
  COUNTRY_CODE_1 # NANP
  COUNTRY_CODE_44 # UK
  COUNTRY_CODE_61 # Australia
}
`, BuiltIn: false},
	{Name: "../schemas/enums/country_enum.graphql", Input: `enum Country {
  Taiwan
  Japan
  Malaysia
  Singapore
  China
  UnitedStatesOfAmerica
  UnitedKingdom
  Australia
  Canada
}
`, BuiltIn: false},
	{Name: "../schemas/enums/language_enum.graphql", Input: `enum Language {
  English
  TraditionalChinese
  SimpleChinese
  Japanese
  Korean
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_gender_enum.graphql", Input: `enum UserGender {
  Male
  Female
  PreferNotToSay
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_plan_enum.graphql", Input: `enum UserPlan {
  Enterprise
  Ultimate
  Pro
  Free
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_role_enum.graphql", Input: `enum UserRole {
  Admin
  Normal
  Guest
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_status_enum.graphql", Input: `enum UserStatus {
  Online
  AFK
  DoNotDisturb
  Offline
}
`, BuiltIn: false},
	{Name: "../schemas/badge.graphql", Input: `type PublicBadge {
  id: UUID!
  title: String!
  description: String!
  type: BadgeType!
  imageURL: String
  createdAt: Time!

  users: [PublicUser!]!
}
`, BuiltIn: false},
	{Name: "../schemas/query.graphql", Input: `type Query {
  searchUsers(input: SearchableUserInput!): SearchableUserConnection!
}

# type Mutation {}

# type Subscription {}
`, BuiltIn: false},
	{Name: "../schemas/scalar.graphql", Input: `scalar UUID
scalar Time
`, BuiltIn: false},
	{Name: "../schemas/searchable.graphql", Input: `# every schemas or graphql types which want to be searchable
# are required to inheritence the structure (of cursor-based pagination) here

# =============== Search Filters (part of Input) =============== #
# input ExampleSearchableFilters {}

# =============== Search By (part of Input) =============== #
# enum ExampleSearchableSortBy {
#     RELEVANCE
# }

# =============== Search Order (part of Input) =============== #
# Note that this field is fixed, and should not build another one for customization
enum SearchableSortOrder {
  ASC
  DESC
}

# ==================== Search Input ==================== #
# input ExampleSearchInput {
#     query: String!
#     after: String
#     first: Int = 10
#     filters: SearchableFilters
#     sortBy: SearchableSortBy = RELEVANCE
#     sortOrder: SearchableSortOrder = DESC
# }

# =============== Current Edge (part of Output) =============== #
interface SearchEdge {
  # node: data of the result, this should be implement in each models require search functionality
  searchCursor: String!
}

# =============== Page Info (part of Output) =============== #
type SearchPageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startSearchCursor: String
  endSearchCursor: String
}

# =============== Search Output (Connection) =============== #
interface SearchConnection {
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../schemas/theme.graphql", Input: `type PublicTheme {
  id: UUID!
  name: String!
  #   authorId: UUID!
  version: String!
  isDefault: Boolean!
  downloadURL: String
  #   downloadCount: Int!
  createdAt: Time!
  updatedAt: Time!

  # relations
  author: PublicUser!
}
`, BuiltIn: false},
	{Name: "../schemas/user.graphql", Input: `# the complete user structure: app/models/schemas/user_schema.go
# this schema file is only use for go graphql to improve better user experience

type PublicUser {
  # id: UUID!
  name: String! # the identifier of the PublicUser
  displayName: String!
  email: String! # the secondary indentifier of the PublicUser
  # password: String!
  # refreshToken: String!
  # loginCount: Int
  # blockLoginUtil: Time!
  # userAgent: String!
  role: UserRole!
  plan: UserPlan!
  # prevStatus: UserStatus!
  status: UserStatus!
  createdAt: Time!
  updatedAt: Time!

  # relations
  userInfo: PublicUserInfo!
  badges: [PublicBadge!]!
  themes: [PublicTheme!]!
}

# =============== Searchable Filters & SortBy & Input =============== #
input SearchableUserFilters {
  role: UserRole
  plan: UserPlan
  status: UserStatus
  hasAvatar: Boolean
  country: Country
  isOnline: Boolean
}

enum SearchableUserSortBy {
  RELEVANCE
  NAME # using this to check both the name and display name fields
  LAST_ACTIVE
  CREATED_AT
}

input SearchableUserInput {
  query: String! # the input from the frontend
  after: String # base64 encoded cursor
  first: Int = 10 # the number of data we want to extract
  filters: SearchableUserFilters
  sortBy: SearchableUserSortBy = RELEVANCE
  sortOrder: SearchableSortOrder = DESC
}

# =============== Searchable Edge & Connection =============== #

type SearchableUserEdge implements SearchEdge {
  node: PublicUser!
  searchCursor: String!
}

type SearchableUserConnection implements SearchConnection {
  searchEdges: [SearchableUserEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../schemas/user_info.graphql", Input: `type PublicUserInfo {
  # id: UUID!
  # userId: UUID!
  coverBackgroundURL: String
  avatarURL: String
  header: String
  introduction: String
  gender: UserGender!
  country: Country
  birthDate: Time!
  updatedAt: Time!
}
`, BuiltIn: false},
	{Name: "../schemas/users_to_badges.graphql", Input: `type PublicUsersToBadges {
  userId: UUID!
  badgeId: UUID!
  createdAt: Time!

  user: PublicUser!
  badge: PublicBadge!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
