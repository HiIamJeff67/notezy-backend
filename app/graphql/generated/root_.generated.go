// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	gqlmodels "notezy-backend/app/graphql/models"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	PublicBadge struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ImageURL    func(childComplexity int) int
		PublicID    func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	PublicTheme struct {
		Author        func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DownloadCount func(childComplexity int) int
		DownloadURL   func(childComplexity int) int
		IsDefault     func(childComplexity int) int
		Name          func(childComplexity int) int
		PublicID      func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	PublicUser struct {
		Badges      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		Name        func(childComplexity int) int
		Plan        func(childComplexity int) int
		PublicID    func(childComplexity int) int
		Role        func(childComplexity int) int
		Status      func(childComplexity int) int
		Themes      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UserInfo    func(childComplexity int) int
	}

	PublicUserInfo struct {
		AvatarURL          func(childComplexity int) int
		BirthDate          func(childComplexity int) int
		Country            func(childComplexity int) int
		CoverBackgroundURL func(childComplexity int) int
		Gender             func(childComplexity int) int
		Header             func(childComplexity int) int
		Introduction       func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
	}

	PublicUsersToBadges struct {
		Badge     func(childComplexity int) int
		BadgeID   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	Query struct {
		SearchUsers func(childComplexity int, input gqlmodels.SearchUserInput) int
	}

	SearchBadgeConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchBadgeEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}

	SearchPageInfo struct {
		EndEncodedSearchCursor   func(childComplexity int) int
		HasNextPage              func(childComplexity int) int
		HasPreviousPage          func(childComplexity int) int
		StartEncodedSearchCursor func(childComplexity int) int
	}

	SearchThemeConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchThemeEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}

	SearchUserConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchUserEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "PublicBadge.createdAt":
		if e.complexity.PublicBadge.CreatedAt == nil {
			break
		}

		return e.complexity.PublicBadge.CreatedAt(childComplexity), true

	case "PublicBadge.description":
		if e.complexity.PublicBadge.Description == nil {
			break
		}

		return e.complexity.PublicBadge.Description(childComplexity), true

	case "PublicBadge.imageURL":
		if e.complexity.PublicBadge.ImageURL == nil {
			break
		}

		return e.complexity.PublicBadge.ImageURL(childComplexity), true

	case "PublicBadge.publicId":
		if e.complexity.PublicBadge.PublicID == nil {
			break
		}

		return e.complexity.PublicBadge.PublicID(childComplexity), true

	case "PublicBadge.title":
		if e.complexity.PublicBadge.Title == nil {
			break
		}

		return e.complexity.PublicBadge.Title(childComplexity), true

	case "PublicBadge.type":
		if e.complexity.PublicBadge.Type == nil {
			break
		}

		return e.complexity.PublicBadge.Type(childComplexity), true

	case "PublicBadge.users":
		if e.complexity.PublicBadge.Users == nil {
			break
		}

		return e.complexity.PublicBadge.Users(childComplexity), true

	case "PublicTheme.author":
		if e.complexity.PublicTheme.Author == nil {
			break
		}

		return e.complexity.PublicTheme.Author(childComplexity), true

	case "PublicTheme.createdAt":
		if e.complexity.PublicTheme.CreatedAt == nil {
			break
		}

		return e.complexity.PublicTheme.CreatedAt(childComplexity), true

	case "PublicTheme.downloadCount":
		if e.complexity.PublicTheme.DownloadCount == nil {
			break
		}

		return e.complexity.PublicTheme.DownloadCount(childComplexity), true

	case "PublicTheme.downloadURL":
		if e.complexity.PublicTheme.DownloadURL == nil {
			break
		}

		return e.complexity.PublicTheme.DownloadURL(childComplexity), true

	case "PublicTheme.isDefault":
		if e.complexity.PublicTheme.IsDefault == nil {
			break
		}

		return e.complexity.PublicTheme.IsDefault(childComplexity), true

	case "PublicTheme.name":
		if e.complexity.PublicTheme.Name == nil {
			break
		}

		return e.complexity.PublicTheme.Name(childComplexity), true

	case "PublicTheme.publicId":
		if e.complexity.PublicTheme.PublicID == nil {
			break
		}

		return e.complexity.PublicTheme.PublicID(childComplexity), true

	case "PublicTheme.updatedAt":
		if e.complexity.PublicTheme.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicTheme.UpdatedAt(childComplexity), true

	case "PublicTheme.version":
		if e.complexity.PublicTheme.Version == nil {
			break
		}

		return e.complexity.PublicTheme.Version(childComplexity), true

	case "PublicUser.badges":
		if e.complexity.PublicUser.Badges == nil {
			break
		}

		return e.complexity.PublicUser.Badges(childComplexity), true

	case "PublicUser.createdAt":
		if e.complexity.PublicUser.CreatedAt == nil {
			break
		}

		return e.complexity.PublicUser.CreatedAt(childComplexity), true

	case "PublicUser.displayName":
		if e.complexity.PublicUser.DisplayName == nil {
			break
		}

		return e.complexity.PublicUser.DisplayName(childComplexity), true

	case "PublicUser.email":
		if e.complexity.PublicUser.Email == nil {
			break
		}

		return e.complexity.PublicUser.Email(childComplexity), true

	case "PublicUser.name":
		if e.complexity.PublicUser.Name == nil {
			break
		}

		return e.complexity.PublicUser.Name(childComplexity), true

	case "PublicUser.plan":
		if e.complexity.PublicUser.Plan == nil {
			break
		}

		return e.complexity.PublicUser.Plan(childComplexity), true

	case "PublicUser.publicId":
		if e.complexity.PublicUser.PublicID == nil {
			break
		}

		return e.complexity.PublicUser.PublicID(childComplexity), true

	case "PublicUser.role":
		if e.complexity.PublicUser.Role == nil {
			break
		}

		return e.complexity.PublicUser.Role(childComplexity), true

	case "PublicUser.status":
		if e.complexity.PublicUser.Status == nil {
			break
		}

		return e.complexity.PublicUser.Status(childComplexity), true

	case "PublicUser.themes":
		if e.complexity.PublicUser.Themes == nil {
			break
		}

		return e.complexity.PublicUser.Themes(childComplexity), true

	case "PublicUser.updatedAt":
		if e.complexity.PublicUser.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicUser.UpdatedAt(childComplexity), true

	case "PublicUser.userInfo":
		if e.complexity.PublicUser.UserInfo == nil {
			break
		}

		return e.complexity.PublicUser.UserInfo(childComplexity), true

	case "PublicUserInfo.avatarURL":
		if e.complexity.PublicUserInfo.AvatarURL == nil {
			break
		}

		return e.complexity.PublicUserInfo.AvatarURL(childComplexity), true

	case "PublicUserInfo.birthDate":
		if e.complexity.PublicUserInfo.BirthDate == nil {
			break
		}

		return e.complexity.PublicUserInfo.BirthDate(childComplexity), true

	case "PublicUserInfo.country":
		if e.complexity.PublicUserInfo.Country == nil {
			break
		}

		return e.complexity.PublicUserInfo.Country(childComplexity), true

	case "PublicUserInfo.coverBackgroundURL":
		if e.complexity.PublicUserInfo.CoverBackgroundURL == nil {
			break
		}

		return e.complexity.PublicUserInfo.CoverBackgroundURL(childComplexity), true

	case "PublicUserInfo.gender":
		if e.complexity.PublicUserInfo.Gender == nil {
			break
		}

		return e.complexity.PublicUserInfo.Gender(childComplexity), true

	case "PublicUserInfo.header":
		if e.complexity.PublicUserInfo.Header == nil {
			break
		}

		return e.complexity.PublicUserInfo.Header(childComplexity), true

	case "PublicUserInfo.introduction":
		if e.complexity.PublicUserInfo.Introduction == nil {
			break
		}

		return e.complexity.PublicUserInfo.Introduction(childComplexity), true

	case "PublicUserInfo.updatedAt":
		if e.complexity.PublicUserInfo.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicUserInfo.UpdatedAt(childComplexity), true

	case "PublicUsersToBadges.badge":
		if e.complexity.PublicUsersToBadges.Badge == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.Badge(childComplexity), true

	case "PublicUsersToBadges.badgeId":
		if e.complexity.PublicUsersToBadges.BadgeID == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.BadgeID(childComplexity), true

	case "PublicUsersToBadges.createdAt":
		if e.complexity.PublicUsersToBadges.CreatedAt == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.CreatedAt(childComplexity), true

	case "PublicUsersToBadges.user":
		if e.complexity.PublicUsersToBadges.User == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.User(childComplexity), true

	case "PublicUsersToBadges.userId":
		if e.complexity.PublicUsersToBadges.UserID == nil {
			break
		}

		return e.complexity.PublicUsersToBadges.UserID(childComplexity), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["input"].(gqlmodels.SearchUserInput)), true

	case "SearchBadgeConnection.searchEdges":
		if e.complexity.SearchBadgeConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.SearchEdges(childComplexity), true

	case "SearchBadgeConnection.searchPageInfo":
		if e.complexity.SearchBadgeConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.SearchPageInfo(childComplexity), true

	case "SearchBadgeConnection.searchTime":
		if e.complexity.SearchBadgeConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.SearchTime(childComplexity), true

	case "SearchBadgeConnection.totalCount":
		if e.complexity.SearchBadgeConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.TotalCount(childComplexity), true

	case "SearchBadgeEdge.encodedSearchCursor":
		if e.complexity.SearchBadgeEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchBadgeEdge.EncodedSearchCursor(childComplexity), true

	case "SearchBadgeEdge.node":
		if e.complexity.SearchBadgeEdge.Node == nil {
			break
		}

		return e.complexity.SearchBadgeEdge.Node(childComplexity), true

	case "SearchPageInfo.endEncodedSearchCursor":
		if e.complexity.SearchPageInfo.EndEncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchPageInfo.EndEncodedSearchCursor(childComplexity), true

	case "SearchPageInfo.hasNextPage":
		if e.complexity.SearchPageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.SearchPageInfo.HasNextPage(childComplexity), true

	case "SearchPageInfo.hasPreviousPage":
		if e.complexity.SearchPageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.SearchPageInfo.HasPreviousPage(childComplexity), true

	case "SearchPageInfo.startEncodedSearchCursor":
		if e.complexity.SearchPageInfo.StartEncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchPageInfo.StartEncodedSearchCursor(childComplexity), true

	case "SearchThemeConnection.searchEdges":
		if e.complexity.SearchThemeConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchThemeConnection.SearchEdges(childComplexity), true

	case "SearchThemeConnection.searchPageInfo":
		if e.complexity.SearchThemeConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchThemeConnection.SearchPageInfo(childComplexity), true

	case "SearchThemeConnection.searchTime":
		if e.complexity.SearchThemeConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchThemeConnection.SearchTime(childComplexity), true

	case "SearchThemeConnection.totalCount":
		if e.complexity.SearchThemeConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchThemeConnection.TotalCount(childComplexity), true

	case "SearchThemeEdge.encodedSearchCursor":
		if e.complexity.SearchThemeEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchThemeEdge.EncodedSearchCursor(childComplexity), true

	case "SearchThemeEdge.node":
		if e.complexity.SearchThemeEdge.Node == nil {
			break
		}

		return e.complexity.SearchThemeEdge.Node(childComplexity), true

	case "SearchUserConnection.searchEdges":
		if e.complexity.SearchUserConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchUserConnection.SearchEdges(childComplexity), true

	case "SearchUserConnection.searchPageInfo":
		if e.complexity.SearchUserConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchUserConnection.SearchPageInfo(childComplexity), true

	case "SearchUserConnection.searchTime":
		if e.complexity.SearchUserConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchUserConnection.SearchTime(childComplexity), true

	case "SearchUserConnection.totalCount":
		if e.complexity.SearchUserConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchUserConnection.TotalCount(childComplexity), true

	case "SearchUserEdge.encodedSearchCursor":
		if e.complexity.SearchUserEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchUserEdge.EncodedSearchCursor(childComplexity), true

	case "SearchUserEdge.node":
		if e.complexity.SearchUserEdge.Node == nil {
			break
		}

		return e.complexity.SearchUserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputSearchBadgeCursorFields,
		ec.unmarshalInputSearchBadgeFilters,
		ec.unmarshalInputSearchBadgeInput,
		ec.unmarshalInputSearchThemeCursorFields,
		ec.unmarshalInputSearchThemeFilters,
		ec.unmarshalInputSearchThemeInput,
		ec.unmarshalInputSearchUserCursorFields,
		ec.unmarshalInputSearchUserFilters,
		ec.unmarshalInputSearchUserInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/enums/badge_type_enum.graphql", Input: `enum BadgeType {
  Diamond
  Golden
  Silver
  Bronze
  Steel
}
`, BuiltIn: false},
	{Name: "../schemas/enums/country_code_enum.graphql", Input: `enum CountryCode {
  COUNTRY_CODE_886 # Taiwan
  COUNTRY_CODE_81 # Japan
  COUNTRY_CODE_60 # Malaysia
  COUNTRY_CODE_65 # Singapore
  COUNTRY_CODE_86 # China
  COUNTRY_CODE_1 # NANP
  COUNTRY_CODE_44 # UK
  COUNTRY_CODE_61 # Australia
}
`, BuiltIn: false},
	{Name: "../schemas/enums/country_enum.graphql", Input: `enum Country {
  Taiwan
  Japan
  Malaysia
  Singapore
  China
  UnitedStatesOfAmerica
  UnitedKingdom
  Australia
  Canada
}
`, BuiltIn: false},
	{Name: "../schemas/enums/language_enum.graphql", Input: `enum Language {
  English
  TraditionalChinese
  SimpleChinese
  Japanese
  Korean
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_gender_enum.graphql", Input: `enum UserGender {
  Male
  Female
  PreferNotToSay
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_plan_enum.graphql", Input: `enum UserPlan {
  Enterprise
  Ultimate
  Pro
  Free
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_role_enum.graphql", Input: `enum UserRole {
  Admin
  Normal
  Guest
}
`, BuiltIn: false},
	{Name: "../schemas/enums/user_status_enum.graphql", Input: `enum UserStatus {
  Online
  AFK
  DoNotDisturb
  Offline
}
`, BuiltIn: false},
	{Name: "../schemas/badge.graphql", Input: `type PublicBadge {
  # id: UUID!
  publicId: String! # the encoded of this field is the identifier of the PublicBadge
  title: String!
  description: String!
  type: BadgeType!
  imageURL: String
  createdAt: Time!

  # relations
  users: [PublicUser!]!
}

# =============== Search Filters & SortBy & SortOrder =============== #

input SearchBadgeFilters {
  type: BadgeType
}

enum SearchBadgeSortBy {
  RELEVANCE
  TITLE
  CREATED_AT
}

input SearchBadgeInput {
  query: String!
  after: String
  first: Int = 10
  filters: SearchBadgeFilters
  sortBy: SearchBadgeSortBy = RELEVANCE
  sortOrderr: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchBadgeEnvironmentAttributes {}

input SearchBadgeCursorFields {
  publicId: String!
  # environmentAttributes: SearchBadgeEnvironmentAttributes
}

# =============== Search Edge & Connection =============== #

type SearchBadgeEdge implements SearchEdge {
  encodedSearchCursor: String! # the search identifier
  node: PublicBadge! # the search result
}

type SearchBadgeConnection implements SearchConnection {
  searchEdges: [SearchBadgeEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../schemas/query.graphql", Input: `type Query {
  searchUsers(input: SearchUserInput!): SearchUserConnection!
}

# type Mutation {}

# type Subscription {}
`, BuiltIn: false},
	{Name: "../schemas/scalar.graphql", Input: `scalar UUID
scalar Time
`, BuiltIn: false},
	{Name: "../schemas/search.graphql", Input: `# every schemas or graphql types which want to be searchable
# are required to inheritence the structure (of cursor-based pagination) here

# =============== Search Filters (part of Input) =============== #
# input ExampleSearchFilters {}

# =============== Search Sort By (part of Input) =============== #
# enum ExampleSearchSortBy {
#     RELEVANCE
# }

# =============== Search Sort Order (part of Input) =============== #
# Note that this field is fixed, and should not build another one for customization
enum SearchSortOrder {
  ASC
  DESC
}

# ==================== Search Input ==================== #
# input ExampleSearchInput {
#     query: String!
#     after: String
#     first: Int = 10
#     filters: SearchFilters
#     sortBy: SearchSortBy = RELEVANCE
#     sortOrder: SearchSortOrder = DESC
# }

# =============== Current Edge (part of Output) =============== #
interface SearchEdge {
  # node: data of the result, this should be implement in each models require search functionality
  encodedSearchCursor: String!
}

# =============== Page Info (part of Output) =============== #
type SearchPageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startEncodedSearchCursor: String
  endEncodedSearchCursor: String
}

# =============== Search Output (Connection) =============== #
interface SearchConnection {
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../schemas/theme.graphql", Input: `type PublicTheme {
  # id: UUID!
  publicId: String! # the encoded of this field is the identifier of the PublicTheme
  name: String!
  #   authorId: UUID!
  version: String!
  isDefault: Boolean!
  downloadURL: String
  downloadCount: Int!
  createdAt: Time!
  updatedAt: Time!

  # relations
  author: PublicUser!
}

# =============== Search Filters & SortBy & Input =============== #

input SearchThemeFilters {
  isDefault: Boolean
  downloadCountGreaterThan: Int
}

enum SearchThemeSortBy {
  RELEVANCE
  NAME
  LAST_UPDATE
  CREATED_AT
}

input SearchThemeInput {
  query: String!
  after: String
  first: Int = 10
  filters: SearchThemeFilters
  sortBy: SearchThemeSortBy = RELEVANCE
  sortOrder: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchThemeEnvironmentAttributes {}

input SearchThemeCursorFields {
  publicId: String!
  # environmentAttributes: SearchThemeEnvironmentAttributes
}

# =============== Search Edge & Connection =============== #

type SearchThemeEdge implements SearchEdge {
  encodedSearchCursor: String! # the search identifier
  node: PublicTheme! # the search result
}

type SearchThemeConnection implements SearchConnection {
  searchEdges: [SearchThemeEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../schemas/user.graphql", Input: `# the complete user structure: app/models/schemas/user_schema.go
# this schema file is only use for go graphql to improve better user experience

type PublicUser {
  # id: UUID!
  publicId: String! # the encoded of this field is the identifier of the PublicUser
  name: String!
  displayName: String!
  email: String!
  # password: String!
  # refreshToken: String!
  # loginCount: Int
  # blockLoginUtil: Time!
  # userAgent: String!
  role: UserRole!
  plan: UserPlan!
  # prevStatus: UserStatus!
  status: UserStatus!
  createdAt: Time!
  updatedAt: Time!

  # relations
  userInfo: PublicUserInfo!
  badges: [PublicBadge!]!
  themes: [PublicTheme!]!
}

# =============== Search Filters & SortBy & Input =============== #

input SearchUserFilters {
  role: UserRole
  plan: UserPlan
  status: UserStatus
  hasAvatar: Boolean
  country: Country
  isOnline: Boolean
}

enum SearchUserSortBy {
  RELEVANCE
  NAME # using this to check both the name and display name fields
  LAST_ACTIVE
  CREATED_AT
}

input SearchUserInput {
  query: String! # the input from the frontend
  after: String # base64 encoded cursor
  first: Int = 10 # the number of data we want to extract
  filters: SearchUserFilters
  sortBy: SearchUserSortBy = RELEVANCE
  sortOrder: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchUserEnvironmentAttributes {}

# use the below fields to encoded it into base64
# and included some attributes as weights of the search algorithm
# for better search experience
input SearchUserCursorFields {
  publicId: String!
  # environmentAttributes: SearchUserEnvironmentAttributes
  # add some weight to effect the searching result here
}

# =============== Search Edge & Connection =============== #

type SearchUserEdge implements SearchEdge {
  encodedSearchCursor: String! # the encoded search identifier
  node: PublicUser! # the search result
}

type SearchUserConnection implements SearchConnection {
  searchEdges: [SearchUserEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../schemas/user_info.graphql", Input: `type PublicUserInfo {
  # id: UUID!
  # userId: UUID!
  coverBackgroundURL: String
  avatarURL: String
  header: String
  introduction: String
  gender: UserGender!
  country: Country
  birthDate: Time!
  updatedAt: Time!
}
`, BuiltIn: false},
	{Name: "../schemas/users_to_badges.graphql", Input: `type PublicUsersToBadges {
  userId: UUID!
  badgeId: UUID!
  createdAt: Time!

  user: PublicUser!
  badge: PublicBadge!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
