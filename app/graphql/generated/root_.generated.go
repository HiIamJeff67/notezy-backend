// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	gqlmodels "notezy-backend/app/graphql/models"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	PrivateMaterial struct {
		ContentKey       func(childComplexity int) int
		ContentType      func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DeletedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		ParentSubShelf   func(childComplexity int) int
		ParentSubShelfID func(childComplexity int) int
		ParseMediaType   func(childComplexity int) int
		Size             func(childComplexity int) int
		Type             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	PrivateRootShelf struct {
		CreatedAt       func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		ID              func(childComplexity int) int
		LastAnalyzedAt  func(childComplexity int) int
		Name            func(childComplexity int) int
		Owner           func(childComplexity int) int
		TotalMaterials  func(childComplexity int) int
		TotalShelfNodes func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	PrivateSubShelf struct {
		CreatedAt      func(childComplexity int) int
		DeletedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		Materials      func(childComplexity int) int
		Name           func(childComplexity int) int
		NextSubShelves func(childComplexity int) int
		Path           func(childComplexity int) int
		PrevSubShelfID func(childComplexity int) int
		RootShelf      func(childComplexity int) int
		RootShelfID    func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	PublicBadge struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ImageURL    func(childComplexity int) int
		PublicID    func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	PublicTheme struct {
		Author        func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DownloadCount func(childComplexity int) int
		DownloadURL   func(childComplexity int) int
		IsDark        func(childComplexity int) int
		IsDefault     func(childComplexity int) int
		Name          func(childComplexity int) int
		PublicID      func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	PublicUser struct {
		Badges      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Plan        func(childComplexity int) int
		PublicID    func(childComplexity int) int
		Role        func(childComplexity int) int
		Status      func(childComplexity int) int
		Themes      func(childComplexity int) int
		UserInfo    func(childComplexity int) int
	}

	PublicUserInfo struct {
		AvatarURL          func(childComplexity int) int
		BirthDate          func(childComplexity int) int
		Country            func(childComplexity int) int
		CoverBackgroundURL func(childComplexity int) int
		Gender             func(childComplexity int) int
		Header             func(childComplexity int) int
		Introduction       func(childComplexity int) int
	}

	Query struct {
		SearchRootShelves func(childComplexity int, input gqlmodels.SearchRootShelfInput) int
		SearchThemes      func(childComplexity int, input gqlmodels.SearchThemeInput) int
		SearchUsers       func(childComplexity int, input gqlmodels.SearchUserInput) int
	}

	SearchBadgeConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchBadgeEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}

	SearchPageInfo struct {
		EndEncodedSearchCursor   func(childComplexity int) int
		HasNextPage              func(childComplexity int) int
		HasPreviousPage          func(childComplexity int) int
		StartEncodedSearchCursor func(childComplexity int) int
	}

	SearchRootShelfConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchRootShelfEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}

	SearchThemeConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchThemeEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}

	SearchUserConnection struct {
		SearchEdges    func(childComplexity int) int
		SearchPageInfo func(childComplexity int) int
		SearchTime     func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	SearchUserEdge struct {
		EncodedSearchCursor func(childComplexity int) int
		Node                func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "PrivateMaterial.contentKey":
		if e.complexity.PrivateMaterial.ContentKey == nil {
			break
		}

		return e.complexity.PrivateMaterial.ContentKey(childComplexity), true

	case "PrivateMaterial.contentType":
		if e.complexity.PrivateMaterial.ContentType == nil {
			break
		}

		return e.complexity.PrivateMaterial.ContentType(childComplexity), true

	case "PrivateMaterial.createdAt":
		if e.complexity.PrivateMaterial.CreatedAt == nil {
			break
		}

		return e.complexity.PrivateMaterial.CreatedAt(childComplexity), true

	case "PrivateMaterial.deletedAt":
		if e.complexity.PrivateMaterial.DeletedAt == nil {
			break
		}

		return e.complexity.PrivateMaterial.DeletedAt(childComplexity), true

	case "PrivateMaterial.id":
		if e.complexity.PrivateMaterial.ID == nil {
			break
		}

		return e.complexity.PrivateMaterial.ID(childComplexity), true

	case "PrivateMaterial.name":
		if e.complexity.PrivateMaterial.Name == nil {
			break
		}

		return e.complexity.PrivateMaterial.Name(childComplexity), true

	case "PrivateMaterial.parentSubShelf":
		if e.complexity.PrivateMaterial.ParentSubShelf == nil {
			break
		}

		return e.complexity.PrivateMaterial.ParentSubShelf(childComplexity), true

	case "PrivateMaterial.parentSubShelfId":
		if e.complexity.PrivateMaterial.ParentSubShelfID == nil {
			break
		}

		return e.complexity.PrivateMaterial.ParentSubShelfID(childComplexity), true

	case "PrivateMaterial.parseMediaType":
		if e.complexity.PrivateMaterial.ParseMediaType == nil {
			break
		}

		return e.complexity.PrivateMaterial.ParseMediaType(childComplexity), true

	case "PrivateMaterial.size":
		if e.complexity.PrivateMaterial.Size == nil {
			break
		}

		return e.complexity.PrivateMaterial.Size(childComplexity), true

	case "PrivateMaterial.type":
		if e.complexity.PrivateMaterial.Type == nil {
			break
		}

		return e.complexity.PrivateMaterial.Type(childComplexity), true

	case "PrivateMaterial.updatedAt":
		if e.complexity.PrivateMaterial.UpdatedAt == nil {
			break
		}

		return e.complexity.PrivateMaterial.UpdatedAt(childComplexity), true

	case "PrivateRootShelf.createdAt":
		if e.complexity.PrivateRootShelf.CreatedAt == nil {
			break
		}

		return e.complexity.PrivateRootShelf.CreatedAt(childComplexity), true

	case "PrivateRootShelf.deletedAt":
		if e.complexity.PrivateRootShelf.DeletedAt == nil {
			break
		}

		return e.complexity.PrivateRootShelf.DeletedAt(childComplexity), true

	case "PrivateRootShelf.id":
		if e.complexity.PrivateRootShelf.ID == nil {
			break
		}

		return e.complexity.PrivateRootShelf.ID(childComplexity), true

	case "PrivateRootShelf.lastAnalyzedAt":
		if e.complexity.PrivateRootShelf.LastAnalyzedAt == nil {
			break
		}

		return e.complexity.PrivateRootShelf.LastAnalyzedAt(childComplexity), true

	case "PrivateRootShelf.name":
		if e.complexity.PrivateRootShelf.Name == nil {
			break
		}

		return e.complexity.PrivateRootShelf.Name(childComplexity), true

	case "PrivateRootShelf.owner":
		if e.complexity.PrivateRootShelf.Owner == nil {
			break
		}

		return e.complexity.PrivateRootShelf.Owner(childComplexity), true

	case "PrivateRootShelf.totalMaterials":
		if e.complexity.PrivateRootShelf.TotalMaterials == nil {
			break
		}

		return e.complexity.PrivateRootShelf.TotalMaterials(childComplexity), true

	case "PrivateRootShelf.totalShelfNodes":
		if e.complexity.PrivateRootShelf.TotalShelfNodes == nil {
			break
		}

		return e.complexity.PrivateRootShelf.TotalShelfNodes(childComplexity), true

	case "PrivateRootShelf.updatedAt":
		if e.complexity.PrivateRootShelf.UpdatedAt == nil {
			break
		}

		return e.complexity.PrivateRootShelf.UpdatedAt(childComplexity), true

	case "PrivateSubShelf.createdAt":
		if e.complexity.PrivateSubShelf.CreatedAt == nil {
			break
		}

		return e.complexity.PrivateSubShelf.CreatedAt(childComplexity), true

	case "PrivateSubShelf.deletedAt":
		if e.complexity.PrivateSubShelf.DeletedAt == nil {
			break
		}

		return e.complexity.PrivateSubShelf.DeletedAt(childComplexity), true

	case "PrivateSubShelf.id":
		if e.complexity.PrivateSubShelf.ID == nil {
			break
		}

		return e.complexity.PrivateSubShelf.ID(childComplexity), true

	case "PrivateSubShelf.materials":
		if e.complexity.PrivateSubShelf.Materials == nil {
			break
		}

		return e.complexity.PrivateSubShelf.Materials(childComplexity), true

	case "PrivateSubShelf.name":
		if e.complexity.PrivateSubShelf.Name == nil {
			break
		}

		return e.complexity.PrivateSubShelf.Name(childComplexity), true

	case "PrivateSubShelf.nextSubShelves":
		if e.complexity.PrivateSubShelf.NextSubShelves == nil {
			break
		}

		return e.complexity.PrivateSubShelf.NextSubShelves(childComplexity), true

	case "PrivateSubShelf.path":
		if e.complexity.PrivateSubShelf.Path == nil {
			break
		}

		return e.complexity.PrivateSubShelf.Path(childComplexity), true

	case "PrivateSubShelf.prevSubShelfId":
		if e.complexity.PrivateSubShelf.PrevSubShelfID == nil {
			break
		}

		return e.complexity.PrivateSubShelf.PrevSubShelfID(childComplexity), true

	case "PrivateSubShelf.rootShelf":
		if e.complexity.PrivateSubShelf.RootShelf == nil {
			break
		}

		return e.complexity.PrivateSubShelf.RootShelf(childComplexity), true

	case "PrivateSubShelf.rootShelfId":
		if e.complexity.PrivateSubShelf.RootShelfID == nil {
			break
		}

		return e.complexity.PrivateSubShelf.RootShelfID(childComplexity), true

	case "PrivateSubShelf.updatedAt":
		if e.complexity.PrivateSubShelf.UpdatedAt == nil {
			break
		}

		return e.complexity.PrivateSubShelf.UpdatedAt(childComplexity), true

	case "PublicBadge.createdAt":
		if e.complexity.PublicBadge.CreatedAt == nil {
			break
		}

		return e.complexity.PublicBadge.CreatedAt(childComplexity), true

	case "PublicBadge.description":
		if e.complexity.PublicBadge.Description == nil {
			break
		}

		return e.complexity.PublicBadge.Description(childComplexity), true

	case "PublicBadge.imageURL":
		if e.complexity.PublicBadge.ImageURL == nil {
			break
		}

		return e.complexity.PublicBadge.ImageURL(childComplexity), true

	case "PublicBadge.publicId":
		if e.complexity.PublicBadge.PublicID == nil {
			break
		}

		return e.complexity.PublicBadge.PublicID(childComplexity), true

	case "PublicBadge.title":
		if e.complexity.PublicBadge.Title == nil {
			break
		}

		return e.complexity.PublicBadge.Title(childComplexity), true

	case "PublicBadge.type":
		if e.complexity.PublicBadge.Type == nil {
			break
		}

		return e.complexity.PublicBadge.Type(childComplexity), true

	case "PublicBadge.users":
		if e.complexity.PublicBadge.Users == nil {
			break
		}

		return e.complexity.PublicBadge.Users(childComplexity), true

	case "PublicTheme.author":
		if e.complexity.PublicTheme.Author == nil {
			break
		}

		return e.complexity.PublicTheme.Author(childComplexity), true

	case "PublicTheme.createdAt":
		if e.complexity.PublicTheme.CreatedAt == nil {
			break
		}

		return e.complexity.PublicTheme.CreatedAt(childComplexity), true

	case "PublicTheme.downloadCount":
		if e.complexity.PublicTheme.DownloadCount == nil {
			break
		}

		return e.complexity.PublicTheme.DownloadCount(childComplexity), true

	case "PublicTheme.downloadURL":
		if e.complexity.PublicTheme.DownloadURL == nil {
			break
		}

		return e.complexity.PublicTheme.DownloadURL(childComplexity), true

	case "PublicTheme.isDark":
		if e.complexity.PublicTheme.IsDark == nil {
			break
		}

		return e.complexity.PublicTheme.IsDark(childComplexity), true

	case "PublicTheme.isDefault":
		if e.complexity.PublicTheme.IsDefault == nil {
			break
		}

		return e.complexity.PublicTheme.IsDefault(childComplexity), true

	case "PublicTheme.name":
		if e.complexity.PublicTheme.Name == nil {
			break
		}

		return e.complexity.PublicTheme.Name(childComplexity), true

	case "PublicTheme.publicId":
		if e.complexity.PublicTheme.PublicID == nil {
			break
		}

		return e.complexity.PublicTheme.PublicID(childComplexity), true

	case "PublicTheme.updatedAt":
		if e.complexity.PublicTheme.UpdatedAt == nil {
			break
		}

		return e.complexity.PublicTheme.UpdatedAt(childComplexity), true

	case "PublicTheme.version":
		if e.complexity.PublicTheme.Version == nil {
			break
		}

		return e.complexity.PublicTheme.Version(childComplexity), true

	case "PublicUser.badges":
		if e.complexity.PublicUser.Badges == nil {
			break
		}

		return e.complexity.PublicUser.Badges(childComplexity), true

	case "PublicUser.createdAt":
		if e.complexity.PublicUser.CreatedAt == nil {
			break
		}

		return e.complexity.PublicUser.CreatedAt(childComplexity), true

	case "PublicUser.displayName":
		if e.complexity.PublicUser.DisplayName == nil {
			break
		}

		return e.complexity.PublicUser.DisplayName(childComplexity), true

	case "PublicUser.name":
		if e.complexity.PublicUser.Name == nil {
			break
		}

		return e.complexity.PublicUser.Name(childComplexity), true

	case "PublicUser.plan":
		if e.complexity.PublicUser.Plan == nil {
			break
		}

		return e.complexity.PublicUser.Plan(childComplexity), true

	case "PublicUser.publicId":
		if e.complexity.PublicUser.PublicID == nil {
			break
		}

		return e.complexity.PublicUser.PublicID(childComplexity), true

	case "PublicUser.role":
		if e.complexity.PublicUser.Role == nil {
			break
		}

		return e.complexity.PublicUser.Role(childComplexity), true

	case "PublicUser.status":
		if e.complexity.PublicUser.Status == nil {
			break
		}

		return e.complexity.PublicUser.Status(childComplexity), true

	case "PublicUser.themes":
		if e.complexity.PublicUser.Themes == nil {
			break
		}

		return e.complexity.PublicUser.Themes(childComplexity), true

	case "PublicUser.userInfo":
		if e.complexity.PublicUser.UserInfo == nil {
			break
		}

		return e.complexity.PublicUser.UserInfo(childComplexity), true

	case "PublicUserInfo.avatarURL":
		if e.complexity.PublicUserInfo.AvatarURL == nil {
			break
		}

		return e.complexity.PublicUserInfo.AvatarURL(childComplexity), true

	case "PublicUserInfo.birthDate":
		if e.complexity.PublicUserInfo.BirthDate == nil {
			break
		}

		return e.complexity.PublicUserInfo.BirthDate(childComplexity), true

	case "PublicUserInfo.country":
		if e.complexity.PublicUserInfo.Country == nil {
			break
		}

		return e.complexity.PublicUserInfo.Country(childComplexity), true

	case "PublicUserInfo.coverBackgroundURL":
		if e.complexity.PublicUserInfo.CoverBackgroundURL == nil {
			break
		}

		return e.complexity.PublicUserInfo.CoverBackgroundURL(childComplexity), true

	case "PublicUserInfo.gender":
		if e.complexity.PublicUserInfo.Gender == nil {
			break
		}

		return e.complexity.PublicUserInfo.Gender(childComplexity), true

	case "PublicUserInfo.header":
		if e.complexity.PublicUserInfo.Header == nil {
			break
		}

		return e.complexity.PublicUserInfo.Header(childComplexity), true

	case "PublicUserInfo.introduction":
		if e.complexity.PublicUserInfo.Introduction == nil {
			break
		}

		return e.complexity.PublicUserInfo.Introduction(childComplexity), true

	case "Query.searchRootShelves":
		if e.complexity.Query.SearchRootShelves == nil {
			break
		}

		args, err := ec.field_Query_searchRootShelves_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchRootShelves(childComplexity, args["input"].(gqlmodels.SearchRootShelfInput)), true

	case "Query.searchThemes":
		if e.complexity.Query.SearchThemes == nil {
			break
		}

		args, err := ec.field_Query_searchThemes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchThemes(childComplexity, args["input"].(gqlmodels.SearchThemeInput)), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["input"].(gqlmodels.SearchUserInput)), true

	case "SearchBadgeConnection.searchEdges":
		if e.complexity.SearchBadgeConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.SearchEdges(childComplexity), true

	case "SearchBadgeConnection.searchPageInfo":
		if e.complexity.SearchBadgeConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.SearchPageInfo(childComplexity), true

	case "SearchBadgeConnection.searchTime":
		if e.complexity.SearchBadgeConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.SearchTime(childComplexity), true

	case "SearchBadgeConnection.totalCount":
		if e.complexity.SearchBadgeConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchBadgeConnection.TotalCount(childComplexity), true

	case "SearchBadgeEdge.encodedSearchCursor":
		if e.complexity.SearchBadgeEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchBadgeEdge.EncodedSearchCursor(childComplexity), true

	case "SearchBadgeEdge.node":
		if e.complexity.SearchBadgeEdge.Node == nil {
			break
		}

		return e.complexity.SearchBadgeEdge.Node(childComplexity), true

	case "SearchPageInfo.endEncodedSearchCursor":
		if e.complexity.SearchPageInfo.EndEncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchPageInfo.EndEncodedSearchCursor(childComplexity), true

	case "SearchPageInfo.hasNextPage":
		if e.complexity.SearchPageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.SearchPageInfo.HasNextPage(childComplexity), true

	case "SearchPageInfo.hasPreviousPage":
		if e.complexity.SearchPageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.SearchPageInfo.HasPreviousPage(childComplexity), true

	case "SearchPageInfo.startEncodedSearchCursor":
		if e.complexity.SearchPageInfo.StartEncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchPageInfo.StartEncodedSearchCursor(childComplexity), true

	case "SearchRootShelfConnection.searchEdges":
		if e.complexity.SearchRootShelfConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchRootShelfConnection.SearchEdges(childComplexity), true

	case "SearchRootShelfConnection.searchPageInfo":
		if e.complexity.SearchRootShelfConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchRootShelfConnection.SearchPageInfo(childComplexity), true

	case "SearchRootShelfConnection.searchTime":
		if e.complexity.SearchRootShelfConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchRootShelfConnection.SearchTime(childComplexity), true

	case "SearchRootShelfConnection.totalCount":
		if e.complexity.SearchRootShelfConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchRootShelfConnection.TotalCount(childComplexity), true

	case "SearchRootShelfEdge.encodedSearchCursor":
		if e.complexity.SearchRootShelfEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchRootShelfEdge.EncodedSearchCursor(childComplexity), true

	case "SearchRootShelfEdge.node":
		if e.complexity.SearchRootShelfEdge.Node == nil {
			break
		}

		return e.complexity.SearchRootShelfEdge.Node(childComplexity), true

	case "SearchThemeConnection.searchEdges":
		if e.complexity.SearchThemeConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchThemeConnection.SearchEdges(childComplexity), true

	case "SearchThemeConnection.searchPageInfo":
		if e.complexity.SearchThemeConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchThemeConnection.SearchPageInfo(childComplexity), true

	case "SearchThemeConnection.searchTime":
		if e.complexity.SearchThemeConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchThemeConnection.SearchTime(childComplexity), true

	case "SearchThemeConnection.totalCount":
		if e.complexity.SearchThemeConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchThemeConnection.TotalCount(childComplexity), true

	case "SearchThemeEdge.encodedSearchCursor":
		if e.complexity.SearchThemeEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchThemeEdge.EncodedSearchCursor(childComplexity), true

	case "SearchThemeEdge.node":
		if e.complexity.SearchThemeEdge.Node == nil {
			break
		}

		return e.complexity.SearchThemeEdge.Node(childComplexity), true

	case "SearchUserConnection.searchEdges":
		if e.complexity.SearchUserConnection.SearchEdges == nil {
			break
		}

		return e.complexity.SearchUserConnection.SearchEdges(childComplexity), true

	case "SearchUserConnection.searchPageInfo":
		if e.complexity.SearchUserConnection.SearchPageInfo == nil {
			break
		}

		return e.complexity.SearchUserConnection.SearchPageInfo(childComplexity), true

	case "SearchUserConnection.searchTime":
		if e.complexity.SearchUserConnection.SearchTime == nil {
			break
		}

		return e.complexity.SearchUserConnection.SearchTime(childComplexity), true

	case "SearchUserConnection.totalCount":
		if e.complexity.SearchUserConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchUserConnection.TotalCount(childComplexity), true

	case "SearchUserEdge.encodedSearchCursor":
		if e.complexity.SearchUserEdge.EncodedSearchCursor == nil {
			break
		}

		return e.complexity.SearchUserEdge.EncodedSearchCursor(childComplexity), true

	case "SearchUserEdge.node":
		if e.complexity.SearchUserEdge.Node == nil {
			break
		}

		return e.complexity.SearchUserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputSearchBadgeCursorFields,
		ec.unmarshalInputSearchBadgeFilters,
		ec.unmarshalInputSearchBadgeInput,
		ec.unmarshalInputSearchRootShelfCursorFields,
		ec.unmarshalInputSearchRootShelfInput,
		ec.unmarshalInputSearchThemeCursorFields,
		ec.unmarshalInputSearchThemeFilters,
		ec.unmarshalInputSearchThemeInput,
		ec.unmarshalInputSearchUserCursorFields,
		ec.unmarshalInputSearchUserFilters,
		ec.unmarshalInputSearchUserInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../shared/graphql/schemas/enums/access_control_permission_enum.graphql", Input: `enum AccessControlPermission {
  Read
  Write
  Admin
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/badge_type_enum.graphql", Input: `enum BadgeType {
  Diamond
  Golden
  Silver
  Bronze
  Steel
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/country_code_enum.graphql", Input: `enum CountryCode {
  COUNTRY_CODE_886 # Taiwan
  COUNTRY_CODE_81 # Japan
  COUNTRY_CODE_60 # Malaysia
  COUNTRY_CODE_65 # Singapore
  COUNTRY_CODE_86 # China
  COUNTRY_CODE_1 # NANP
  COUNTRY_CODE_44 # UK
  COUNTRY_CODE_61 # Australia
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/country_enum.graphql", Input: `enum Country {
  Taiwan
  Japan
  Malaysia
  Singapore
  China
  UnitedStatesOfAmerica
  UnitedKingdom
  Australia
  Canada
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/language_enum.graphql", Input: `enum Language {
  English
  TraditionalChinese
  SimpleChinese
  Japanese
  Korean
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/material_content_type_enum.graphql", Input: `enum MaterialContentType {
  Text_Plain
  Text_HTML
  Text_Markdown
  Image_PNG
  Image_JPG
  Image_JPEG
  Image_GIF
  Image_SVG
  Video_MP3
  VIDEO_MP4
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/material_type_enum.graphql", Input: `enum MaterialType {
  Textbook
  Notebook
  LearningCards
  Workflow
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/user_gender_enum.graphql", Input: `enum UserGender {
  Male
  Female
  PreferNotToSay
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/user_plan_enum.graphql", Input: `enum UserPlan {
  Enterprise
  Ultimate
  Pro
  Free
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/user_role_enum.graphql", Input: `enum UserRole {
  Admin
  Normal
  Guest
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/enums/user_status_enum.graphql", Input: `enum UserStatus {
  Online
  AFK
  DoNotDisturb
  Offline
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/badge.graphql", Input: `type PublicBadge {
  # id: UUID!
  publicId: String! # the encoded of this field is the identifier of the PublicBadge
  title: String!
  description: String!
  type: BadgeType!
  imageURL: String
  createdAt: Time!

  # relations
  users: [PublicUser!]!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/fields.graphql", Input: `# every schemas or graphql types which want to be searchable
# are required to inheritence the structure (of cursor-based pagination) here

# =============== Search Filters (part of Input) =============== #
# input ExampleSearchFilters {}

# =============== Search Sort By (part of Input) =============== #
# enum ExampleSearchSortBy {
#     RELEVANCE
# }

# =============== Search Sort Order (part of Input) =============== #
# Note that this field is fixed, and should not build another one for customization
enum SearchSortOrder {
  ASC
  DESC
}

# ==================== Search Input ==================== #
# input ExampleSearchInput {
#     query: String!
#     after: String
#     first: Int = 10
#     filters: SearchFilters
#     sortBy: SearchSortBy = RELEVANCE
#     sortOrder: SearchSortOrder = DESC
# }

# =============== Current Edge (part of Output) =============== #
interface SearchEdge {
  encodedSearchCursor: String!
  # node: the data of the result, this should be implement in each models require search functionality
}

# =============== Page Info (part of Output) =============== #
type SearchPageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startEncodedSearchCursor: String
  endEncodedSearchCursor: String
}

# =============== Search Output (Connection) =============== #
interface SearchConnection {
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/material.graphql", Input: `type PrivateMaterial {
  id: UUID!
  parentSubShelfId: UUID!
  name: String!
  type: MaterialType!
  size: Int64!
  contentKey: String!
  contentType: MaterialContentType!
  parseMediaType: String!
  deletedAt: Time
  updatedAt: Time!
  createdAt: Time!

  # relations
  parentSubShelf: PrivateSubShelf!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/query.graphql", Input: `type Query {
  searchUsers(input: SearchUserInput!): SearchUserConnection!
  searchThemes(input: SearchThemeInput!): SearchThemeConnection!
  searchRootShelves(input: SearchRootShelfInput!): SearchRootShelfConnection!
}

# type Mutation {}

# type Subscription {}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/root_shelf.graphql", Input: `type PrivateRootShelf {
  id: UUID!
  name: String!
  totalShelfNodes: Int32!
  totalMaterials: Int32!
  lastAnalyzedAt: Time!
  deletedAt: Time
  updatedAt: Time!
  createdAt: Time!

  # relations
  owner: [PublicUser!]!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/scalar.graphql", Input: `scalar Int32
scalar Int64
scalar UUID
scalar Time
scalar Base64Bytes
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/search_badges.graphql", Input: `# =============== Search Filters & SortBy & SortOrder =============== #

input SearchBadgeFilters {
  type: BadgeType
}

enum SearchBadgeSortBy {
  RELEVANCE
  TITLE
  CREATED_AT
}

input SearchBadgeInput {
  query: String!
  after: String
  first: Int = 10
  filters: SearchBadgeFilters
  sortBy: SearchBadgeSortBy = RELEVANCE
  sortOrderr: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchBadgeEnvironmentAttributes {}

input SearchBadgeCursorFields {
  publicId: String!
  # environmentAttributes: SearchBadgeEnvironmentAttributes
}

# =============== Search Edge & Connection =============== #

type SearchBadgeEdge implements SearchEdge {
  encodedSearchCursor: String! # the search identifier
  node: PublicBadge! # the search result
}

type SearchBadgeConnection implements SearchConnection {
  searchEdges: [SearchBadgeEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/search_root_shelves.graphql", Input: `# =============== Search SortBy & Input =============== #

enum SearchRootShelfSortBy {
  RELEVANCE
  NAME
  LAST_UPDATE
  CREATED_AT
}

input SearchRootShelfInput {
  query: String!
  after: String
  first: Int = 10
  sortBy: SearchRootShelfSortBy = RELEVANCE
  sortOrder: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchRootShelfEnvironmentAttributes {}

input SearchRootShelfCursorFields {
  id: UUID!
  # environmentAttributes: SearchRootShelfEnvironmentAttributes
}

# =============== Search Edge & Connection =============== #

type SearchRootShelfEdge implements SearchEdge {
  encodedSearchCursor: String!
  node: PrivateRootShelf!
}

type SearchRootShelfConnection implements SearchConnection {
  searchEdges: [SearchRootShelfEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/search_themes.graphql", Input: `# =============== Search Filters & SortBy & Input =============== #

input SearchThemeFilters {
  isDefault: Boolean
  downloadCountGreaterThan: Int
}

enum SearchThemeSortBy {
  RELEVANCE
  NAME
  LAST_UPDATE
  CREATED_AT
}

input SearchThemeInput {
  query: String!
  after: String
  first: Int = 10
  filters: SearchThemeFilters
  sortBy: SearchThemeSortBy = RELEVANCE
  sortOrder: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchThemeEnvironmentAttributes {}

input SearchThemeCursorFields {
  publicId: String!
  # environmentAttributes: SearchThemeEnvironmentAttributes
}

# =============== Search Edge & Connection =============== #

type SearchThemeEdge implements SearchEdge {
  encodedSearchCursor: String! # the search identifier
  node: PublicTheme! # the search result
}

type SearchThemeConnection implements SearchConnection {
  searchEdges: [SearchThemeEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/search_users.graphql", Input: `# =============== Search Filters & SortBy & Input =============== #

input SearchUserFilters {
  role: UserRole
  plan: UserPlan
  status: UserStatus
  hasAvatar: Boolean
  country: Country
  isOnline: Boolean
}

enum SearchUserSortBy {
  RELEVANCE
  NAME # using this to check both the name and display name fields
  LAST_ACTIVE
  CREATED_AT
}

input SearchUserInput {
  query: String! # the input from the frontend
  after: String # base64 encoded cursor
  first: Int = 10 # the number of data we want to extract
  filters: SearchUserFilters
  sortBy: SearchUserSortBy = RELEVANCE
  sortOrder: SearchSortOrder = DESC
}

# =============== Search Cursor Fields =============== #

# type SearchUserEnvironmentAttributes {}

# use the below fields to encoded it into base64
# and included some attributes as weights of the search algorithm
# for better search experience
input SearchUserCursorFields {
  publicId: String!
  # environmentAttributes: SearchUserEnvironmentAttributes
  # add some weight to effect the searching result here
}

# =============== Search Edge & Connection =============== #

type SearchUserEdge implements SearchEdge {
  encodedSearchCursor: String! # the encoded search identifier
  node: PublicUser! # the search result
}

type SearchUserConnection implements SearchConnection {
  searchEdges: [SearchUserEdge!]!
  searchPageInfo: SearchPageInfo!
  totalCount: Int!
  searchTime: Float!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/sub_shelf.graphql", Input: `type PrivateSubShelf {
  id: UUID!
  name: String!
  rootShelfId: UUID!
  prevSubShelfId: UUID
  path: [UUID!]!
  deletedAt: Time
  updatedAt: Time!
  createdAt: Time!

  # relations
  rootShelf: PrivateRootShelf!
  nextSubShelves: [PrivateSubShelf!]!
  materials: [PrivateMaterial!]!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/theme.graphql", Input: `type PublicTheme {
  # id: UUID!
  publicId: String! # the encoded of this field is the identifier of the PublicTheme
  name: String!
  isDark: Boolean!
  #   authorId: UUID!
  version: String!
  isDefault: Boolean!
  downloadURL: String
  downloadCount: Int64!
  createdAt: Time!
  updatedAt: Time!

  # relations
  author: PublicUser!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/user.graphql", Input: `# the complete user structure: app/models/schemas/user_schema.go
# this schema file is only use for go graphql to improve better user experience

type PublicUser {
  # id: UUID!
  publicId: String! # the encoded of this field is the identifier of the PublicUser
  name: String!
  displayName: String!
  # email: String!
  # password: String!
  # refreshToken: String!
  # loginCount: Int
  # blockLoginUtil: Time!
  # userAgent: String!
  role: UserRole!
  plan: UserPlan!
  # prevStatus: UserStatus!
  status: UserStatus!
  createdAt: Time!
  # updatedAt: Time!

  # relations
  userInfo: PublicUserInfo!
  badges: [PublicBadge!]!
  themes: [PublicTheme!]!
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/schemas/user_info.graphql", Input: `type PublicUserInfo {
  # id: UUID!
  # userId: UUID!
  avatarURL: String
  coverBackgroundURL: String
  header: String
  introduction: String
  gender: UserGender!
  country: Country
  birthDate: Time!
  # updatedAt: Time!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
